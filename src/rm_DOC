**Documentation for the Record Management (RM) component**


Main idea
---------
The RM component is a client of the PF component and hence uses its methods and
classes to open, create, update and destroy files. Each file is made of pages. 

The first page of a file is the **header page** which stores some information 
about the file. The other pages are **data pages** and contain the records 
themselves - and also some information for management though.

In each data page there is a header section which stores infos such as the next 
page where there is empty space and a bitmap indicating which slots (see below
for the definition of a slot) of the page are empty. An integer with the number
of the next free page is also put in the header (allows to fin an empty slot in
the file quickly to insert a new record in it)

Then come the slots. All the slots are the same size (size of a record) and the
RM puts as many slots as possible in a page. A page containing free space is a 
page in which at least one slot is free (corresponds to a 1 value in the bitmap 
in the page header).


RID class
---------
The RID class represents a record identifier. A rid has only two private
attributes: its page number and its slot number. It has also two methods that
allow to retrieve this numbers from it: GetPageNum(PageNum &pageNum) and
GetSlotNum(SlotNum &slotNum). We have also implemented two other methods
GetPage() and GetSlot() two retrieve them without having to pass an integer as
parameter of the method.

RID has two constructors, the first one initialize the RID with default page and
slot numbers: -1 (NULL_PAGE and NULL_SLOT constants).

The isValidRID() method just return true if page and slot numbers are greater
than 0 and false otherwise. The RID class is widely used in the other RM classes
and will also be used by other components of Tinybase.


Bitmap class
------------
The aim for the Bitmap class is to represent the occupation of slots in a given 
page. Bitmap is used by the RM_PageHeader class as an attribute (see below). 

This class is fairly simple: it has a pointer to an allocated buffer called 
**bitValues** and each time an instruction is given to the bitmap via the 
appropriate methods (set, reset, test to respectively put a bit to 1, to 0 or 
get the value of a bit) it acts on the corresponding bit in the buffer. Of not
bit is given to the set or reset method then we use C++ method overloading to 
perform the action on all the bits of the bitmap.

The methods **from_buf(const char *& buf)** and **to_buf(char *& buf)** allow 
the bitmap to be respectively read or written from/to a buffer. These two 
methods are called inside the from_buf and to_buf method of the RM_PageHeader 
class (see below).


Header classes
--------------
We chose to create two classes called **RM_FileHeader** and **RM_PageHeader**
to represent respectively the header of a file (i.e. its first page) and the
header of a page. Each class has two methods allow translation between
class object and bytes :

    - the **from_buf(const char *& buf)** method allows the header object to
    load from a given buffer

    - the **to_buf(char *& buf)** method allows the header object to be written 
    to a given buffer

**RM_FileHeader** contains three private integer attributes: the number of the
first free page, the number of pages in the file and the size of the records in
the file. It also has setters and getters for these three attributes.

**RM_PageHeader** is a little more complex class. Its main attribute is public 
and is a **Bitmap** object called **freeSlots**. FreeSlots is widely used by 
other classes such as RM_FileHandle. 
It has also two int attributes nbSlots and nextFreePage to store respectively 
the number of slots in the page and the number of the next page containing at 
least one free slot.
RM_PageHeader has a method size() which returns an integer giving the size in 
BYTES of the header in the page. That means to read the first slot for instance
you would offset your buffer with the value returned by this size() method. If 
we had chosen to represent the page header with a struct the equivalent of 
size() would be sizeof(RM_PageHeader). RM_PageHeader also has a method called 
getNbFreeSlots() to return the number of slots that are free (and so available
to store records). This methods just loops through the freeSlots bitmap 
to count the number of free slots in the page.


RM_FileHandle class
-------------------
**RM_FileHandle** manipulates records: Insert, delete, update, etc. To use this
class you must first call its Open() method and pass it a pointer to the
associated PF_FileHandle object. RM_FileHandle keeps two flags to know if it is
open and if the header of the open file has been mofified since opening (this
last flag is usefull for the RM_Manager to know if it has then to write the
header on disk again).

The **GetNumSlots()** may be a little bit tricky. It creates a nbSlot integer
with initial value of 0. Then, it starts incrementing it until the size of a
page with nbSlots slots is greater than PF_PAGE_SIZE. To calculate the size of a
page with nbSlots slots we need to instanciate a RM_PageHeader with nbSlots as
parameter and the formula: pageSize = pageHeader.size() + slotsNb * recordSize
Since this size increases with nbSlots, we will eventualy find the maximum
number of slots for the page.


RM_Manager class
----------------
**RM_Manager** is the top-level class in our RM. It has four methods called
CreateFile(), DestroyFile(), OpenFile() and CloseFile(). Their names are very
explicit. In the implementation of these methods RM_Manager calls the methods of
its PF_Manager atrribute **pfm**, which it a reference to the PF_Manager object
passed in the constructor of RM_Manager.

On important thing RM_Manager does in its methods is calling methods of other
classes such as RM_PageHeader, RM_FileHeader to bufferize them i.e. to write
them into a buffer. And RM_Manager got the buffer address in the first place
with its PF_Manager attribute.


RM_FileScan class
-----------------
**RM_FileScan** provides a way to perform a lookup on the record and will be
used later when performing queries on the database.
When its method openScan() is called the parameters are copied into attributes
and then (once openScan has been called) the client can call the getNextRec()
method to get the first record of the file that matches the given parameters,
and so on.

RM_FileScan has a few privates attributes to keep track of the progress in the
scan. **scaning** is a boolean indicating whether a scan is opened or not.
**currentRID** is an RID object which value is changed in the getNextRec()
method, it allows RM_FileScan to take the lookup back where it left it when
getNextRec() is called.

And then we also have a private method called **performMatching(char *pData)**
which is basically the heart of the RM_FileScan class. Indeed performMatching()
is the method that actually performs the comparison between each record in the
file and the parameters passed to the openScan() method. To do so, we use a
switch statement on the **compOp** attribute (the comOp value was copied before
when openScan was called) and then compare the value pointed by **pData** (
offseted with the **attrOffset** though) with the **value** atribute (value also
given when openScan was called).


Testing the RM Component
------------------------
When testing our RM component we encountered several errors. Most of them were
easy to correct but a few errors (such as seqfault) were very hard even with the
help of a debugger. We also had to normalize our error/warning codes so they are
the same in every class of the RM.
Most of the problems we had while debugging our code were related to memory
allocation, pointers and references.
For instance in the RM_Manager class, in the CloseFile() method we had a
variable called pif. Pif was actually a copy of the pf_FileHandle attribute in
RM_FileHandle, and as a consequence when we would close pif, the pf_FileHandle
wasn't actually closed in the RM_FileHandle. So we had to change the code and
make pif a reference to the pf_FileHandle attribute. That works perfectly now!
