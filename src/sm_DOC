**Documentation for the System Management (SM) component**


tinybase, dbcreate and dbdestroy utilities
------------------------------------------
The three utilities are used to set up the databases (creating folder, catalog
tables, etc.).

**dbcreate**
dbcreate first checks if the name given for the database doesn't already exists,
and creates a folder for the new database. Then we create to files using a rm
manager: relcat and attrcat. These two files represent the catalogs for the
database. relcat contains the list of the tables of the database, and attrcat
contains the list of the attributes for all the tables.

Then we have to insert two new tuples in relcat: one for relcat itself, and one
for attrcat. We also have to insert 4 tuples in attrcat for the attributes of
relcat, and 6 other tuples in attrcat for the attributes of attrcat itself.
To insert all these tuples, we cannot use the SM_Manager class since the
SM_Manager precisely uses our relcat and attrcat tables to perform its
insertions. We have to allocate memory for the tuples and fill them
"manually", and then insert them using rm. When that is done, we just have to
close the rm manager and we are done!

**tinybase**
The tinybase program is the core of the sgbd. It creates a PF_Manager, a
RM_Manager, a IX_Manager, a SM_Manager and a QL_Manager and calls the
parser. Then the user prompts its commands. We make sure to close
everything when the user is done.

**dbdestroy**
dbdestroy just destroys the folder where the database files are located. Of
course we perform a check before doing so to make sure the database exists.



SM_Manager
----------

Functions here are listed in the order they are in sm_manager.cc.

**FormatName(char *string)**
This auxiliary function format the string given as input into lower case. If the
string is wider than `MAXNAME`, it returns a non-zero error code.

**AttrRecFromRA(char * relName, char * attrName, RM_Record * rec)**
The output parameter record of this auxiliary function is set to the record from
attrcat corresponding to given relName relation name and attrName attribute
name. This auxialiary function helps code to be factorized.

**RelFromR(char * relName, RM_Record * rec)**
The output parameter record of this auxiliary function is set to the record from
relcat corresponding to given relName relation name and attrName attribute
name. This auxialiary function helps code to be factorized.

**OpenDb(const char *dbName)**
This method, along with method CloseDb, change to the directory for the database
named *dbName (using system call chdir), then open the files containing the
system catalogs for the database. System catalogs are described below. 

**CloseDb()**
This method should close all open files in the current database. Closing the
files automatically causes all relevant buffers to be flushed to disk.

**CreateTable(const char *relName, int attrCount, AttrInfo *attributes)**
This function is three fold: first input parameters are tested and formatted.
First, relation and attribute names are limited to MAXNAME = 25 characters each
and must begin with a letter. Every relation name must be unique within a
database, and a given relation may have attributes named all different.
Then is the working part and we first update the system catalogs: a tuple for
the new relation should be added to a catalog relation called relcat and a tuple
for each attribute should be added to a catalog relation called attrcat. After
updating the catalogs, method RM_Manager::CreateFile is called to create a file
that will hold the tuples of the new relation.
Finally comes cleaning part, we free the memory from transient objects.

**DropTable(const char *relName)**
This function destroys relation relName, along with all indexes on
the relation by calling method RM_Manager::DestroyFile. Information about the
destroyed relation is deleted from catalogs relcat and attrcat.

**CreateIndex(const char *relName, const char *attrName)**
This creates an index on attribute attrName of relation relName and builds the
index for the current tuples in the relation. Only one index may be created for
each attribute of a relation.
It first formats string input from the user then checks there is not already
an index on the specified attribute.
This brand new index is then added to catalog attrcat, then method
IX_Manager::CreateIndex eventually creates the index. Building the index is
three-fold: open the index; using RM component methods to scan through the
records to be indexed; close the index.
Finally we clean all and reduce the memory print.

**DropIndex(const char *relName, const char *attrName)**
This function destroys the index on attribute attrName of relation relName. It
first format input strings then checks that the index exists. Finally catalog
attrcat is updated, and method IX_Manager::DestroyIndex called to destroy the
index.

**Load(const char*relName, const char*filename)**
This method is used to insert all the tuples in the file of ‘*fileName’ into the
relation ‘*relName’.To fulfill this, first we scan all the records in relcat and
attract , and we use two structures Relationtuple and DataAttrInfo to store all
the information about the relation and the attributes, like its length and type.
For the loading, we load the file line by line and find each attribute by the
detection of commas. Here, according to the different type of attribute in the
relation, we convert the record in files from ‘string’ format to int, float or
string. When a character string is too long, we just choose to simply generate
a nonzero return and stop loadiing.

**Help()**
In this method, the sm_manager prints the list of the relations in the existing
base. Therefore, the sm_manager's method Help() is supposed to enter the relcat
catalog. After opening the files, it goes through the lines thanks to a FileScan
instance and reads the first entry of the tables' line. Then, it prints the name
of the relation thanks to the Printer Class (we have to create an instance of it
in the method) and its print() method.
 
**Help(const char* relname)**
In this method, we are given the name of a table or relation. We have to print
the attributes of this relation.Therefore, we use the attrcat catalog to find
them. In fact, the attrcat catalog owns each relation attributes. We scan the
catalog with an option to find exactly the relation matching the given relname.
Then, we instanciate a Printer for the attributes, and print them.
 
**Print(const char* relname)**
There, we are given a relname and we are supposed to print all the tuples of
this relation. We create a table of DataAttrInfo. This table we fill with a
FileScan going through the tuples. Then, we instanciate a Printer and this
Printer prints the tuples by going through the DataAttrInfo table.
