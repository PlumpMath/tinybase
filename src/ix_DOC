**Documentation for the Indexing (IX) component**


Implementation choices
----------------------
We implemented the indexing component using a B+ tree. Each node or leaf is
represented with a page in the file associated with our index. Thus, in all our
methods we can refer to a node by its **Page Number** (i.e. PageNum variable).

The tree is made of node and each node is made of a several things:
    - A header (containing some useful information about the node such as its
    parent, the previous node, etc.)
    - Keys (values used to navigate through the tree). Thus keys can be INT,
    FLOAT, or STRING according of the attrtype our index will be used for.
    - Pointers, i.e. the number of an other PageNum
There are three types of nodes :
    - Thee root, i.e. the first node at the top of the tree
    - Internal nodes
    - Leaf nodes, i.e nodes at the bottom of the tree

There are also **buckets** (they are not nodes so to say though) which are pages
containing the RIDs for a given value. Buckets are pointed from the leaf nodes,
and if there is not enough space in a bucket to store all the RIDs associated
with a given value we use **bucket chaining** (there is a nextBucket field in
the header of a bucket).


Nodes structures
----------------
We have three structures for headers:
    - **IX_FileHeader** is the global header for the file, it is always stored in
    the first page of the file i.e. page 0. It contains the PageNum for the root
    (or -1 if there is no root yet), the attrType of the index (i.e. INT, FLOAT
    or STRING) and the size of the keys in the tree, which is the same as the
    size of the attribute.
    - **IX_NodeHeader** is the header struct for nodes. It's used for all the
    kinds of nodes: root, internal nodes and leaf nodes. It includes the type of
    the node (-1 for root, 0 for internal node and 1 for leaf node), the number
    of keys currently stored in the node, the maximum possible number of keys
    storable in it, and Page Numbers for the node's parent, previous node and
    next node (set to -1 if there is no parent/prev/next node).
    - **IX_BucketHeader** is the heade for buckets. It just contains the number
    of rids stored in it, the maximum number of rid storable and the PageNum
    of the next bucket if bucket chaining is needed (-1 otherwise).

The way pages are written in the file:
    - Root and internal nodes are written this way :
    *Header* *pointer-1* *key0* *pointer0* ... *keyN-1* *pointerN-1*
    Where the number of keys in the node is N. Please note the presence of a
    "-1 pointer" which is very important. Hence there are N+1 pointers but
    only N keys.
    - Leaf nodes are written this way:
    *Header* *key0* *pointer0* ... *keyN-1* *pointerN-1*
    In this nodes the way things work is simple, a key is a value and the
    following pointer is the PageNum of the bucket where the RIDs for this
    value are stored. There are N keys and N pointers.
    - Buckets are written this way:
    *Header* *RID0* *RID1* ... *RIDN-1*
    Also very simple, we have N RIDs put the one after the other.


Insertion algorithm : the basics
--------------------------------
When the tree is initialized there is no node and no bucket.

In our examples each node can contain up to 2 keys (to keep it simple) plus the
-1 pointer if there is one and buckets cain contain up to 2 rids (actual page size
show bucket can contain up to around 500 rids so it's also very simplified).

When the InsertEntry() method is called for the first time a root is created,
but also a first leaf. Then we use a reccursive call to InsertEntryToNode()
with the root number as node number. After the first insertion the tree may
look like this (let's say the inserted value is 13:

======================Figure 1: Tree after first insertion======================

                                  Root (n°1)
                                (2)  __()  __()
                                 |
                                 |
                          First Leaf (n°2)
                             13(3)  __()
                               |
                               |
                      First Bucket (n°3)
                           RID1 __

================================================================================

Let's explain a little bit our notations. n°X means the node/bucket page number
in the file is X. A value into brackets means it's a pointer, a key otherwise.
For example in the first leaf, 13(3) means the key0 is 13 and the pointer0
associated with it 3 (the page number of the first bucket). The (2) in the root
node is the pointer-1 so it is perfectly normal it has no key associated with it.

Then when we insert a new value, let's say 8, the method insertEntryToNode() will
be called with 1 as first parameter (i.e. root nodeNumber). Since the root has
only the -1 pointer it will call insertEntryToLeafNode(2, ...) to delegate the job
to its leaf. The leaf is not full so it calls insertEntryToLeafNodeNoSplit(2,...)
and this method insert the value at the right place (and offsets 13(3) to do so).
We finally get something like this:

======================Figure 2: Tree after second insertion=====================

                                  Root (n°1)
                                (2) __() __()
                                 |
                                 |
                             Leaf (n°2)
                             8(4)  13(3)
                              /      \
                             /        \
                         B.(n°4)    B.(n°3)
                         RID2 __    RID1 __

================================================================================

Of course a new bucket was allocated to store the second RID since the value is
not the same as bucket n°3 (we will cover this later in this document).
So at this point we have a root with an only leaf node child and two buckets
associated with values.

We can insert one more value again, let's say 17. But this time the leaf is full
so insertEntryToLeafNode() will call insertEntryToLeafNodeSplit(). This method
allocates a new page for the "split" leaf, copies the second half of the keys/
pointers of the first leaf into the second leaf.

Then the method use the first key of the second leaf as a "split key". In our
case the splitKey is 13. Since our value - 17 - is higher than the split key,
it will be inserted in the second leaf.

insertEntryToLeafNodeSplit() will then call insertEntryToNode(1, ...) to insert
our new leaf in the parent node of our first leaf (i.e. the root in our case).
The key for the inserted pointer will be the splitKey. So we have:

=========================Figure 3: Tree after leaf split========================

                                      Root (n°1)
                                   (2)  13(5)  __()
                                   /      |
                                  /       |
                          Leaf (n°2)   Leaf (n°5)
                          8(4) __()    13(3)  17(6)
                          /              |      \
                         /               |       \
                    B.(n°4)           B.(n°3)  B.(n°6)
                    RID2 __           RID1 __  RID3 __

================================================================================

So now according to the value of the next insertion we will just insert in the
empty key/pointer couple of leaf N°2 or have to split leaf n°5 (if value is
above 13). Let's say we insert 21 . The process is fairly the same as above,
we get the following tree:

=======================Figure 4: After another leaf split=======================

                                      Root (n°1)
                                   (2)  13(5)  17(7)
                                   /      |        \
                                  /       |         \
                          Leaf (n°2)   Leaf (n°5)   Leaf (n°7)
                          8(4) __()    13(3) __()   17(6) 21(8)
                           |             |            |     \
                           |             |            |      \
                         B.(n°4)      B.(n°3)      B.(n°6)   B.(n°8)
                         RID2 __      RID1 __      RID3 __   RID4 __

================================================================================

Also please note that when performing insertions we always take care of updating
the headers. Let's examine a couple of headers in our example.
Leaf n°2 header is:
{level=1, maxKeyNb=2, nbKey=1, parentPage=1, prevPage=-1, nextPage=5}
The root header is:
{level=-1, maxKeyNb=2, nbKey=2, parentPage=-1, prevPage=-1, nextPage=-1}
The number of keys in the root is 2 since the -1 pointer is not taken into
account (it has no key associated with it anyway).

Now let's come to the tricky part: insertion in an internal node with split.
This is performed by the method InsertEntryToIntlNodeSplit() and is probably one
of the hardest piece of code of our IX to understand. In our case the "internal
node" to split is the root, but it makes no difference except thatwe have to
create a new root for the tree.

Let's say we wan't to add a rid with the key 18 to our tree. The root goes
through all its keys and pointers and since 18>17 it makes a reccursive call to
insertEntryToLeafNode(7, ...). But the leaf n°7 is full so another call to
insertEntryToLeafNodeSplit(7, ...) is made. A new leaf is created with the
splitKey 21 (see above) and 18 is inserted to the leaf n°7 since 18<21.
A call to insertEntryToIntlNode(1, ...) is made with the splitkey 21. Since 1
is full it has to split.

And we have three values to "place" in our two nodes: 13, 17 and 21. We take the
median key - 17 - and "push" it above (in the new root created) by calling
insertEntryToIntlNode(10, ...) because the number of the new root is 10 in our
example.

=======================Figure 5: After internal node split======================

                                     Root (n°10)
                                   (1)  17(11) __()
                                  /         \
                                 /           \
                          Ex-Root (n°1)   Intl node (n°11)
                        (2)  13(5) __()    (7)  21(9) __()
                        /      |            |       \
                       /       |            |        \
               Leaf (n°2)  Leaf (n°5)   Leaf (n°7)    Leaf (n°9)
               8(4) __()   13(3) __()   17(6) 18(12)  21(8) __()
                |            |            |      |       \
                |            |            |      |        \
               B.(n°4)    B.(n°3)    B.(n°6)   B.(n°12)   B.(n°8)
               RID2 __    RID1 __    RID3 __   RID5 __    RID4 __

================================================================================

And as you can see, node n°1 (the ex-root) has become the -1 pointer of the new
root. This change is performed in the InsertEntryToIntlNodeSplit() method. And
we forgot to make this change in the first place, which cost us hours of
debugging...


Insertion with an existing value
--------------------------------

